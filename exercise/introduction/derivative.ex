# Work with functions as symbolic expressions and compute the derivative of functions.
# Part of the problem is to understand how we can represent functions using the data structures that we have in Elixir.
defmodule Derivative do
    @type literal() :: {:const, number()} # 2.39, 1000, -1...
                | {:const, atom()} # Ï€...
                | {:var, atom()} # x, y, z...
    @type expr() :: {:add, expr(), expr()}
                | {:mul, expr(), expr()}
                | literal()

    # 2x + 3 = {:add, {:mul, {:const, 2}, {:var, :x}}, {:const, 3}}
    def deriv({:const, _}, _), do: ...

    def deriv({:var, v}, v), do: ...

    def deriv({:var, y}, _), do: ...

    def deriv({:mul, e1, e2}, v), do: ...

    def deriv({:add, e1, e2}, v), do: ...


end
